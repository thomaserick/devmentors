"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.getTransformedIndexHTML = getTransformedIndexHTML;

var _index = require("@open-wc/building-utils/index-html/index.js");

var _systemJsLegacyResolve = _interopRequireDefault(require("../browser-scripts/system-js-legacy-resolve.js"));

var _polyfillsPresets = require("./polyfills-presets.js");

var _importMaps = require("./import-maps.js");

var _constants = require("../constants.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

const regexpSystemJs = /(<script src=["|']polyfills\/system.*?><\/script>)/g;
/**
 * @typedef {object} TransformIndexHTMLConfig
 * @property {string} indexUrl
 * @property {string} indexHTMLString
 * @property {string} compatibilityMode
 * @property {string} polyfillsMode
 * @property {import('./user-agent-compat').UserAgentCompat} uaCompat
 */

/**
 * @param {TransformIndexHTMLConfig} cfg
 */

function getPolyfills(cfg) {
  if (cfg.polyfillsMode === _constants.polyfillsModes.NONE) {
    return {};
  }

  switch (cfg.compatibilityMode) {
    case _constants.compatibilityModes.MAX:
      return _polyfillsPresets.polyfillsPresets.max;

    case _constants.compatibilityModes.MIN:
      return _polyfillsPresets.polyfillsPresets.all;

    case _constants.compatibilityModes.AUTO:
    case _constants.compatibilityModes.ALWAYS:
      if (cfg.compatibilityMode === _constants.compatibilityModes.AUTO && cfg.uaCompat.modern) {
        return {};
      }

      if (cfg.uaCompat.supportsEsm) {
        return _polyfillsPresets.polyfillsPresets.all;
      }

      return _polyfillsPresets.polyfillsPresets.allWithSystemjs;

    default:
      return {};
  }
}
/**
 * transforms index.html, extracting any modules and import maps and adds them back
 * with the appropriate polyfills, shims and a script loader so that they can be loaded
 * at the right time
 *
 * @param {TransformIndexHTMLConfig} cfg
 */


function getTransformedIndexHTML(cfg) {
  const polyfillModules = [_constants.compatibilityModes.AUTO, _constants.compatibilityModes.ALWAYS].includes(cfg.compatibilityMode) && !cfg.uaCompat.supportsEsm || cfg.compatibilityMode === _constants.compatibilityModes.MAX; // extract input files from index.html


  const resources = (0, _index.extractResources)(cfg.indexHTMLString, {
    removeImportMaps: false
  });
  /** @type {Map<string, string>} */

  const inlineModules = new Map();
  resources.inlineModules.forEach((content, i) => {
    inlineModules.set(`inline-module-${i}.js`, content);
  });
  const files = [...resources.jsModules, ...[...inlineModules.keys()].map(e => `${e}?source=${encodeURIComponent(cfg.indexUrl)}`)];

  if (files.length === 0) {
    return {
      indexHTML: cfg.indexHTMLString,
      inlineModules: new Map(),
      polyfills: []
    };
  } // create a new index.html with injected polyfills and loader script


  const createResult = (0, _index.createIndexHTML)(resources.indexHTML, {
    entries: {
      type: polyfillModules ? 'system' : 'module',
      polyfillDynamicImport: false,
      files
    },
    polyfills: getPolyfills(cfg),
    minify: false,
    preload: false
  });
  let {
    indexHTML
  } = createResult;

  if (polyfillModules) {
    indexHTML = (0, _importMaps.addPolyfilledImportMaps)(indexHTML, resources);
  } // inject systemjs resolver which appends a query param to trigger es5 compilation


  if (polyfillModules) {
    // inject resolver right after system js script, to make sure it's loaded before and systemjs imports
    indexHTML = indexHTML.replace(regexpSystemJs, `$1 \n${_systemJsLegacyResolve.default}`);
  }

  return {
    indexHTML,
    inlineModules,
    polyfills: createResult.files
  };
}