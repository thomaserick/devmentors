"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createCompatibilityTransformMiddleware = createCompatibilityTransformMiddleware;

var _stripAnsi = _interopRequireDefault(require("strip-ansi"));

var _utils = require("../utils/utils.js");

var _messageChannel = require("../utils/message-channel.js");

var _resolveModuleImports = require("../utils/resolve-module-imports.js");

var _compatibilityTransform = require("../utils/compatibility-transform.js");

var _userAgentCompat = require("../utils/user-agent-compat.js");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * @typedef {object} CompatibilityTransformMiddleware
 * @property {string} rootDir
 * @property {boolean} readUserBabelConfig
 * @property {boolean | import('@rollup/plugin-node-resolve').Options} nodeResolve
 * @property {string} compatibilityMode
 * @property {object} [customBabelConfig]
 * @property {string[]} fileExtensions
 * @property {string[]} babelExclude
 * @property {string[]} babelModernExclude
 * @property {string[]} babelModuleExclude
 */

/**
 * @param {string} errorMessage
 */
function logError(errorMessage) {
  // strip babel ansi color codes because they're not colored correctly for the browser terminal
  (0, _messageChannel.sendMessageToActiveBrowsers)('error-message', JSON.stringify((0, _stripAnsi.default)(errorMessage)));
  /* eslint-disable-next-line no-console */

  console.error(`\n${errorMessage}`);
}
/**
 * Sets up a middleware which runs all served js code through babel. Different babel configs
 * are loaded based on the server's configuration.
 *
 * @param {CompatibilityTransformMiddleware} cfg
 */


function createCompatibilityTransformMiddleware(cfg) {
  const resolveModuleImports = cfg.nodeResolve ? (0, _resolveModuleImports.createResolveModuleImports)(cfg.rootDir, cfg.fileExtensions, typeof cfg.nodeResolve === 'boolean' ? undefined : cfg.nodeResolve) : undefined;
  const compatibilityTransform = (0, _compatibilityTransform.createCompatibilityTransform)(cfg, resolveModuleImports);
  /** @type {import('koa').Middleware} */

  async function compatibilityMiddleware(ctx, next) {
    const baseURL = ctx.url.split('?')[0].split('#')[0];

    if ((0, _utils.isPolyfill)(ctx.url) || !cfg.fileExtensions.some(ext => baseURL.endsWith(ext))) {
      return next();
    }

    await next(); // should be a 2xx response

    if (ctx.status < 200 || ctx.status >= 300) {
      return undefined;
    }

    const transformModule = (0, _utils.shoudlTransformToModule)(ctx.url);
    const filePath = (0, _utils.getRequestFilePath)(ctx, cfg.rootDir); // if there is no file path, this file was not served statically

    if (!filePath) {
      return undefined;
    } // Ensure we respond with js content type


    ctx.response.set('content-type', 'text/javascript');

    try {
      const code = await (0, _utils.getBodyAsString)(ctx);
      const uaCompat = (0, _userAgentCompat.getUserAgentCompat)(ctx);
      const transformedCode = await compatibilityTransform({
        uaCompat,
        filePath,
        code,
        transformModule
      });
      ctx.body = transformedCode;
      ctx.status = 200;
      return undefined;
    } catch (error) {
      if (error instanceof _utils.RequestCancelledError) {
        return undefined;
      } // ResolveSyntaxError is thrown when resolveModuleImports runs into a syntax error from
      // the lexer, but babel didn't see any errors. this means either a bug in the lexer, or
      // some experimental syntax. log a message and return the module untransformed to the
      // browser


      if (error instanceof _resolveModuleImports.ResolveSyntaxError) {
        logError(`Could not resolve module imports in ${ctx.url}: Unable to parse the module, this can be due to experimental syntax or a bug in the parser.`);
        return undefined;
      }

      let errorMessage = error.message; // replace babel error messages file path with the request url for readability

      if (errorMessage.startsWith(filePath)) {
        errorMessage = errorMessage.replace(filePath, ctx.url);
      }

      errorMessage = `Error compiling: ${errorMessage}`; // send compile error to browser for logging

      ctx.body = errorMessage;
      ctx.status = 500;
      logError(errorMessage);
    }

    return undefined;
  }

  return compatibilityMiddleware;
}